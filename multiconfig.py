from mint_multiconfig import all_programs, chosen_programs, defaults,  config_step_types, chosen_configs #, all_configs
from dir_config import default_folders, logfile, logfolder
from subprocess import STDOUT, check_call
from shutil import copyfile
import datetime
#from types import *

import logging
import pdb
import os
import re, tempfile, shutil #for the replace function


def exist_create_file(filename):
    exist_create_folder(os.path.dirname(filename))
    if not os.path.exists(filename):
        file = open(filename,'w+')
        comment_char = '#'
        file.write(comment_char + ' file automatically generated by bootstrap script')
        file.close

def exist_create_folder(folderpath):
    if not os.path.exists(folderpath):
        os.makedirs(folderpath)

def backup_file(filename):
    if os.path.exists(filename):
        bkpname=filename + '.backup'
        if not os.path.exists(bkpname):
            shutil.copyfile(filename, bkpname)
        else:
            bkpfolder=bkpname+'s'
            exist_create_folder(bkpfolder)
            shutil.copyfile(filename, bkpfolder + '/' +datetime.datetime.now().strftime("%Y-%m-%d_%H:%M"))
        

        
class bashcommand():

    def __init__(self,s=''):
        self.command = s

    def __add__(self, other):
        if type(other) is str:
            self.command += ' ' + other
            return
        if type(other) is list:
            self.command += ' ' + ' '.join(l)
            return

    def run(self, choseprintlog=False):
        logging.info(self.command)
        self.stdlog = os.popen(self.command)
        for l in self.stdlog:
            pastestring = '\t \t' + l.replace('\n','')
            logging.debug(pastestring)
        if choseprintlog:
            self.printlog()

    def printlog(self):
        print(self.stdlog)
        for l in self.stdlog:
            print(l,end="")


class stuff_to_do():

    def __init__(self,kind,config_dic,default_dic):
        self.kind = kind
        self.config_dic = config_dic
        self.default_dic = default_dic
    
    def get_attr(self, attr, dictionary=False, defaults=False):
        if dictionary == False:
            dictionary = self.config_dic
        if defaults == False:
            defaults = self.default_dic
        if attr in dictionary:
            return dictionary[attr]
        else:
            try:
                return defaults[attr]
            except KeyError:
                logging.warning('warning: get_attr raised on a non-defaulted attribute %s',attr)
                return False

    def build_path(self, raw_path):
    #this is to allow aliases like "home" in the path name
        directory = '/'
        for c in raw_path:
            path_steps = self.get_attr(c,self.config_dic)
            if path_steps:
                for s in path_steps:
                    directory = os.path.join(directory,s)
            else:
                    directory = os.path.join(directory,c)
        return directory

            
class program(stuff_to_do):

    def __init__(self,name):
        self.name = name
        super().__init__('program', all_programs[name] ,defaults)

    def build_install_command(self):
        l = []
        realname=self.name
        if 'aka' in self.config_dic:
            realname = self.get_attr('aka')
        for i in ['is_sudo','install_command']:
            l.append(self.get_attr(i))
        l.append(realname)
        return ' '.join(l)

    def run_install(self):
        logging.debug('installing   '+self.name)
        installer = bashcommand(self.build_install_command())
        installer.run()


    def add_repo(self):
        repo = self.get_attr('repo')
        if repo == defaults['repo']:
            return
        else:
            logging.debug('Adding repo   ' + repo)
            pre = self.get_attr('repo_prequel')
            #pdb.set_trace()
            for c in pre:
                command = bashcommand(c)
                command.run
            repo_adder = bashcommand(self.get_attr('repo_add_command'))
            repo_adder + repo
            repo_adder.run()
            #pdb.set_trace()
            updater = bashcommand(self.get_attr('repo_update_command'))
            updater.run()

    def install(self):
        self.add_repo()
        self.run_install()
        self.prog_config()


    def prog_config(self):
        c = self.get_attr('config')
        if c == defaults['config']:
            return
        else:
            conf = configuration(c)
            conf.run_all_steps()
    

class configuration(stuff_to_do):

    def __init__(self,name):
        self.name = name
        super().__init__('config', all_configs[name] ,defaults)


    def check_steps(self):
#-------------------diabled for now, need to fied a way to check if a class with that name exists
#        for s in self.config_dic:
#            assert s['type'] in config_step_types, 'error, command type not allowed'
#            if s['type'] not in config_step_types:
#                   return 'error, command type not allowed'
        return

    def run_step(self,step):
        single_step = step['type'](step['content'])
        logging.debug('running step   ' + single_step.__class__.__name__)
        single_step.run()
        
    def run_all_steps(self):
        self.check_steps()
        for s in self.config_dic:
            self.run_step(s)


class make_dir(stuff_to_do):

    def __init__(self, step_content):
        super().__init__('folder', default_folders ,defaults)
        self.raw_path = step_content
        self.dir_path = self.build_path(self.raw_path)

    def run(self):
        if not os.path.exists(self.dir_path):
            os.makedirs(self.dir_path)
        
        
class change_add_line():
    
    def __init__(self,step_content):
        self.filename = step_content['file']
        self.regex = step_content['regex']
        self.newline = step_content['newline']
        

    def run(self):
        self.exec_change_add_line(self.filename, self.regex, self.newline)
        
    def exec_change_add_line(self, filename, match_regex, newline):
        exist_create_file(filename)
        backup_file(filename)
        r = re.compile(match_regex)
        need_to_add = True
        #temp file
        fh, abs_path = tempfile.mkstemp()
        with open(abs_path,'w') as new_file:
            with open(filename) as old_file:
                for line in old_file:
                    if r.match(line):
                        new_file.write(r.sub(newline,line))
                        need_to_add = False
                    else:
                        new_file.write(line)
                if need_to_add:
                    new_file.write("\n")
                    new_file.write(newline)
        os.close(fh)
        shutil.copy(abs_path, filename)


class move_file(stuff_to_do):

    def __init__(self,step_content):
        self.src_dir_raw = step_content['source_dir']
        self.tgt_dir_raw = step_content['target_dir']
        self.filename = step_content['filename']
        super().__init__('folder', default_folders ,defaults)

    def run(self):
        pdb.set_trace()
        self.src_dir = self.build_path(self.src_dir_raw)
        self.tgt_dir = self.build_path(self.tgt_dir_raw)
        src_file_full = os.path.join(self.src_dir, self.filename)
        tgt_file_full = os.path.join(self.tgt_dir, self.filename)
        if not os.path.exists( src_file_full ):
            print('source file not found: %s', src_file_full)
        else:
            backup_file(tgt_file_full)
            shutil.copy(src_file_full, tgt_file_full)
            
        
all_configs = {
    'caps2ctrl' : [ {'type':bashcommand, 'content':'setxkbmap -option ctrl:nocaps'} ],
    'rtorrent_setup' : [ {'type':make_dir, 'content': ['usr_home', 'rDownloads']},
                         {'type':make_dir, 'content': ['usr_home', 'rDownloads','.rSessions']},
                         {'type':change_add_line, 'content': {'file':'/home/lollo/.rtorrent.rc',
                                                                'regex':r'^\s*directory\s*=\s*(\/|$|\"|\').*',
                                                                'newline':'directory = /home/lollo/rDownloads'}},
                         {'type':change_add_line, 'content': {'file':'/home/lollo/.rtorrent.rc',
                                                                'regex':r'^\s*session\s*=\s*(\/|$|\"|\').*',
                                                                'newline':'session = /home/lollo/rDownloads/.rSessions'}}
                       ],
    'dropbox_at_login' : [ {'type':change_add_line, 'content':{'file':'/etc/rc.local',
                                                                 'regex':'.+dropboxd.+',
                                                                 'newline':'~/.dropbox-dist/dropboxd'} } ],
    #to check these hardcoded parameters: sudo fdisk -l | grep -i ntfs ; ls -al /dev/disk/by-uuid/
    'add_media_partition' : [ {'type':make_dir, 'content':['/mediadisk']},
                              {'type': change_add_line, 'content': {'file':'/etc/fstab',
                                                                      'regex':'.*UUID=AA2E6BAF2E6B72ED.*',
                                                                      'newline':'UUID=AA2E6BAF2E6B72ED            /mediadisk   ntfs  auto            0       0' } }],
    'replace_test' : [{'type':change_add_line, 'content': {'file':'/home/lollo/tmp/io.test',
                                                             'regex':'.+di.+',
                                                             'newline':'oddio'} }],
    'add_beet_plugin_libs' : [{'type':bashcommand, 'content':'pip install pylast request discogs-client'},
                              {'type':move_file, 'content': {'source_dir': ['bootstrap_folder'], 'filename':'config.yaml', 'target_dir':['usr_home','.config','beets']} }
    ], #manca beet completion e moving config file
    'adjust_file_association' : [ {'type':change_add_line, 'content': {'file':'/usr/share/applications/defaults.list',
                                                                       'regex':r'.*video.*avi\s*=.*',
                                                                       'newline':'video/x-avi=xplayer.desktop;vlc.desktop'}},
                                  {'type':change_add_line, 'content': {'file':'/usr/share/applications/defaults.list',
                                                                       'regex':r'.*video.*mpeg\s*=.*',
                                                                       'newline':'video/mpeg=xplayer.desktop;vlc.desktop'}},
                                  {'type':change_add_line, 'content': {'file':'/usr/share/applications/defaults.list',
                                                                       'regex':r'.*video.*ogg\s*=.*',
                                                                       'newline':'video/ogg=xplayer.desktop;vlc.desktop'}},
                                  {'type':change_add_line, 'content': {'file':'/usr/share/applications/defaults.list',
                                                                       'regex':r'.*video.*ogg\s*=.*',
                                                                       'newline':'video/mp4=xplayer.desktop;vlc.desktop'}},
                                  {'type':change_add_line, 'content': {'file':'/usr/share/applications/defaults.list',
                                                                       'regex':r'.*video.*m4v\s*=.*',
                                                                       'newline':'video/x-m4v=xplayer.desktop;vlc.desktop'}}
    ],
    'pip-upgrade-setup' : [ {'type': bashcommand, 'content':'pip install --upgrade pip'},
                            {'type': bashcommand, 'content':'pip install setuptools'}
    ]
}


print(logfolder)
logfile_full_path = logfolder + logfile
exist_create_folder(logfolder)
exist_create_file(logfile_full_path)
print(logfile_full_path)
logging.basicConfig( filename=logfile_full_path, level=logging.DEBUG, format='%(levelname)s \t    %(message)s')


logging.info('\n')
logging.info('Begin programs installation: \n')        
for p in chosen_programs:
    prog = program(p)
    logging.info('\n')
    logging.info('Installing--> ' + prog.name)
    prog.install()

logging.info('\n')
logging.info('Begin stand-alone configs: \n')        
for c in chosen_configs:
    conf = configuration(c)
    logging.info('\n')
    logging.info('Configuring--> ' + conf.name)
    conf.run_all_steps()
    

